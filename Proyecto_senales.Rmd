---
title: "Proyecto señales"
author: "Grupo C"
date: "2024-12-26"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tuneR)
library(seewave)
```

```{r}
# Esta función normaliza la amplitud y unifica la frecuencia de muestreo
normalize_and_resample <- function(audio, target_sr = 22050) {
  # Normalizamos la amplitud (entre 0 y 1)
  max_amplitude <- max(abs(audio@left))
  if (max_amplitude > 0) {
    audio@left <- audio@left / max_amplitude
    if (audio@stereo) {
      audio@right <- audio@right / max_amplitude
    }
  }
  
  # Unificamos la frecuencia de muestreo
  audio_resampled <- resamp(audio, f = audio@samp.rate, g = target_sr, output = "Wave")
  
  return(audio_resampled)
}

cutAudio <- function(input_file, 
                     output_file, 
                     duration_seconds = 130, 
                     target_sr = 22050) {
  # Lee la canción (archivo WAV)
  audio <- readWave(input_file)
  
  # Normalizamos y reesampleamos
  audio <- normalize_and_resample(audio, target_sr)
  
  # Frecuencia de muestreo (samples por segundo)
  sr <- audio@samp.rate
  
  # Número de muestras que queremos (130s * sr)
  num_samples <- duration_seconds * sr
  
  # Longitud actual de la señal en muestras (canal izquierdo)
  len_audio <- length(audio@left)
  
  if (len_audio > num_samples) {
    # 1) Si es más larga, recortamos
    audio@left  <- audio@left[1:num_samples]
    if (audio@stereo) {
      audio@right <- audio@right[1:num_samples]
    }
  } else if (len_audio < num_samples) {
    # 2) Si es más corta, rellenamos con ceros (silencio)
    needed <- num_samples - len_audio
    audio@left  <- c(audio@left,  rep(0, needed))
    if (audio@stereo) {
      audio@right <- c(audio@right, rep(0, needed))
    }
  }
  
  # Convertimos a enteros antes de guardar (sino sale un warning)
  audio@left <- round(audio@left * 32767)
  if (audio@stereo) {
    audio@right <- round(audio@right * 32767)
  }
  
  # Guardamos la versión procesada
  writeWave(audio, output_file)
}

```

```{r}
# Directorio principal de entrada
data_dir <- "data"

# Directorio principal de salida
output_main_dir <- "data_recortada"

# Creamos la carpeta de salida si no existe
if(!dir.exists(output_main_dir)) {
  dir.create(output_main_dir)
}

# Obtenemos la lista de subcarpetas dentro de data/ (sin recursividad)
subcarpetas <- list.dirs(path = data_dir, full.names = TRUE, recursive = FALSE)

# Recorremos cada subcarpeta (ej: data/hardstyle, data/jazz, etc.)
for (sub in subcarpetas) {
  
  # Nombre de la subcarpeta (por ejemplo, "hardstyle", "jazz", etc.)
  nombre_subcarpeta <- basename(sub) 
  
  # Creamos en data_recortada/ una subcarpeta con el mismo nombre
  # Ej: data_recortada/hardstyle
  output_subcarpeta <- file.path(output_main_dir, nombre_subcarpeta)
  if (!dir.exists(output_subcarpeta)) {
    dir.create(output_subcarpeta)
  }
  
  # Listamos los archivos .wav en la subcarpeta original
  wav_files <- list.files(sub, pattern = "\\.wav$", full.names = TRUE)
  
  # Para cada archivo .wav, recortar y guardar
  for (wav in wav_files) {
    # Sacamos el nombre del archivo, p. ej. "cancion1.wav"
    base_name <- basename(wav)
    
    # Definimos dónde se guardará en la carpeta recortada
    out_wav <- file.path(output_subcarpeta, base_name)
    
    # Llamamos a nuestra función cutAudio
    cutAudio(input_file  = wav, 
             output_file = out_wav,
             duration_seconds = 130)  # 2 minutos 10 seg
  }
}
```

```{r}
file1 <- readWave("data_recortada/jazz/Jazz-at-Mladost-Club-No-More-Blues.wav")
file1@right
max(file1@left)
plot(file1)
```

